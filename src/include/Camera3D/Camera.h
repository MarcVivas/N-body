//
// This code is not mine, although is modified by me (marc) on 15/03/2023
// The code was generated by ChatGPT
//

#ifndef N_BODY_CAMERA_H
#define N_BODY_CAMERA_H

class Camera {
public:
    // Constructor, sets default values for camera properties
    Camera(unsigned int winWidth, unsigned int winHeight, glm::vec3 worldDim) {
        this->windowHeight = winHeight;
        this->windowWidth = winWidth;
        this->worldDimensions = worldDim;
        this->isDragging = false;
        this->prevMousePos = glm::vec2(0.0f);

        // The initial position of the camera in 3D space
        this->position = glm::vec3(worldDimensions.x / 2.0f, worldDimensions.y / 2.0f, worldDimensions.y * 2.0f);

        // The center of the world that the camera is looking at
        this->worldCenter = glm::vec3(worldDimensions.x / 2.0f, worldDimensions.y / 2.0f, 0.0f);

        // The up vector of the camera, used for determining orientation
        this->up = glm::vec3(0.0f, 1.0f, 0.0f);

        // The sensitivity of the camera when moving it with the mouse
        this->sensitivity = 0.005f;

        // The speed at which the camera zooms in and out
        this->zoomSpeed = 1.f;

        // The field of view angle of the camera in degrees
        this->fov = 90.0f;

        // The aspect ratio of the camera (width divided by height)
        this->aspectRatio = static_cast<float>(windowWidth) / static_cast<float>(windowHeight);

        // The distance from the camera to the near clipping plane, used for culling objects that are too close
        this->nearClipPlane = 0.1f;

        // The distance from the camera to the far clipping plane, used for culling objects that are too far away
        //this->farClipPlane = glm::length(worldDimensions) + 2.0f;
        this->farClipPlane = worldDimensions.z * 4.0f;
    }

    // Set aspect ratio
    void setAspectRatio(unsigned int winWidth, unsigned int winHeight) {
        this->windowWidth = winWidth;
        this->windowHeight = winHeight;
        this->aspectRatio = static_cast<float>(winWidth) / static_cast<float>(winHeight);
    }

    // Get the view matrix
    glm::mat4 getViewMatrix() const {
        return glm::lookAt(this->position, this->worldCenter, this->up);
    }

    // Get the projection matrix
    glm::mat4 getProjectionMatrix() const {
        return glm::perspective(glm::radians(this->fov), this->aspectRatio, this->nearClipPlane, this->farClipPlane);
    }

    glm::mat4 getModelMatrix() const{
        return glm::mat4(1.f);
    }

    glm::mat4 getModelViewProjection() const {
        return  this->getProjectionMatrix() * this->getViewMatrix() * this->getModelMatrix();
    }


    // Zoom the camera in/out
    void zoomCallback(float deltaTime, float x_offset, float y_offset) {
        this->fov -= (float)y_offset;
        if (this->fov < 1.0f){
            this->fov = 1.0f;
        }
        if (this->fov > 100.0f){
            this->fov = 100.0f;
        }
    }

    // Rotate the camera based on mouse movement
    void rotateCallback(float xoffset, float yoffset) {
        if (!isDragging) {
            // The user is not dragging
            return;
        }

        // Calculate the difference in mouse position
        glm::vec2 delta = glm::vec2(xoffset, yoffset) - this->prevMousePos;
        this->prevMousePos = glm::vec2(xoffset, yoffset);

        // Calculate the rotation angles
        float pitch = delta.y * sensitivity;
        float yaw = -delta.x * sensitivity;

        // Calculate the direction vector and right vector
        glm::vec3 direction = glm::normalize(worldCenter - position);
        glm::vec3 right = glm::normalize(glm::cross(direction, up));

        // Rotate around the up vector
        glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), yaw, up);
        direction = glm::vec3(rotation * glm::vec4(direction, 0.0f));
        right = glm::normalize(glm::cross(direction, up));
        rotation = glm::rotate(glm::mat4(1.0f), pitch, right);
        direction = glm::vec3(rotation * glm::vec4(direction, 0.0f));

        // Update the camera position and world center
        position = worldCenter - direction * glm::length(worldCenter - position);
        up = glm::normalize(glm::cross(right, direction));
    }

    unsigned int getWindowWidth(){
        return this->windowWidth;
    }

    unsigned int getWindowHeight(){
        return this->windowHeight;
    }

private:
    unsigned int windowWidth;
    unsigned int windowHeight;
    glm::vec3 worldDimensions;
    glm::vec3 position;
    glm::vec3 worldCenter;
    glm::vec3 up;
    float sensitivity;
    float zoomSpeed;
    float fov;
    float aspectRatio;
    float nearClipPlane;
    float farClipPlane;
    bool isDragging;     // whether the mouse is dragging the camera
    glm::vec2 prevMousePos;     // the previous mouse position


};

#endif //N_BODY_CAMERA_H
